// @@@ START COPYRIGHT @@@
//
// (C) Copyright 2014 Hewlett-Packard Development Company, L.P.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//
// @@@ END COPYRIGHT @@@

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <dirent.h>
#include <unistd.h>
#include <errno.h>
#include "sqludr.h"

using namespace tmudr;

int getVCLen(SQLUDR_PARAM *inParam, char *input_row)
{
  char *vcInd = ((char *) input_row) + inParam->vc_ind_offset;
  unsigned long vcIndLen = inParam->vc_ind_len;
  int inDataLen = 0;
  if (vcIndLen == 2)
    inDataLen = *((unsigned short *) vcInd);
  else
    inDataLen = *((unsigned long *) vcInd);
  return inDataLen;
}

void setVCLen(SQLUDR_PARAM *outParam,  char *output_row, int len)
{
  char *vcInd = ((char *) output_row) + outParam->vc_ind_offset;
  outParam->vc_ind_len = 2;
  *((unsigned short *) vcInd) = (unsigned short) len;
}

static void setIntOutputColumn(SQLUDR_INT32 *tgt,
                               SQLUDR_INT16 *indPtr,
                               const char *src)
{
  char *endptr = NULL;

  *tgt = (SQLUDR_INT32) strtol(src, &endptr, 10);

  if (endptr == NULL || *endptr != 0 || endptr == src)
    {
      // no valid number read, treat this as a NULL value
      *tgt = 0;
      *indPtr = -1;
    }
  else
    *indPtr = 0;
}

static void setCharOutputColumn(char *tgt,
                                SQLUDR_INT16 *indPtr,
                                SQLUDR_PARAM *param,
                                const char *src)
{
  strncpy(tgt, src, param->data_len);
  int len = strlen(src);
  if (len < param->data_len)
    {
      if (len > 0)
        {
          // set the remainder of the field to blanks
          memset(tgt+len, ' ', param->data_len - len); 
        }
      else
        {
          // treat a blank value as a NULL value
          *indPtr = -1;
          memset(tgt, ' ', param->data_len);
        }
    }
}

static void setVarCharOutputColumn(char *tgt,
                                   SQLUDR_INT16 *lenPtr,
                                   SQLUDR_INT16 *indPtr,
                                   SQLUDR_PARAM *param,
                                   const char *src)
{
  int len = strlen(src);

  strncpy(tgt, src, param->data_len);
  *indPtr = 0;
  if (len < param->data_len)
    {
      *lenPtr = len;
      // just to be clean, blank out remainder of the field
      memset(tgt+len, ' ', param->data_len - len); 

      if (len == 0)
        // treat a blank value as a NULL value
        *indPtr = -1;
    }
  else
    *lenPtr = param->data_len;
}

// -----------------------------------------------------------------
// Function to read event log files generated by Trafodion C++ code
//
// SQL Syntax to invoke this function:
//
//  select * from udf(event_log_reader( [options] ));
//
// The optional [options] argument is a character constant. The
// following options are supported:
//  f: add file name output columns (see below)
//  t: turn on tracing
//  d: loop in the runtime code, to be able to attach a debugger
//     (debug build only)
//  p: force parallel execution on workstation environment with
//     virtual nodes (debug build only)
//
// Returned columns:
//
// log_ts        timestamp(6),
// severity      char(10 bytes) character set utf8,
// component     char(24 bytes) character set utf8,
// node_number   integer,
// cpu           integer,
// pin           integer,
// process_name  char(12 bytes) character set utf8,
// sql_code      integer,
// query_id      varchar(200 bytes) character set utf8,
// message       varchar(4000 bytes) character set utf8
//
// if option "f" was specified, we have three more columns:
//
// log_file_node integer not null,
// log_file_name varchar(200 bytes) character set utf8 not null,
// log_file_line integer not null
//
// together, these three extra columns are unique for each result row
// -----------------------------------------------------------------

extern "C" SQLUDR_LIBFUNC SQLUDR_INT32 TRAF_CPP_EVENT_LOG_READER(
     SQLUDR_CHAR *input_row,
     SQLUDR_TMUDF_TRAIL_ARGS)
{
  if (calltype == SQLUDR_CALLTYPE_FINAL)
    return SQLUDR_SUCCESS;

  SQLUDR_Q_STATE qstate;

  // input parameters
  int addFileColumns = 0;
  int doTrace = 0;
  int startWithALoop = 0;
  int pid = (int) getpid();

  if (udrinfo->num_inputs >= 1)
    {
      char *options = input_row + udrinfo->inputs[0].data_offset;
      int optionsLen = (int) udrinfo->inputs[0].data_len;

      for (int i=0; i<optionsLen; i++)
        switch (options[i])
          {
          case ' ':
          case 'f': // handled below with addFileColumns
          case 'p': // handled at compile time
            break;

          case 't':
            doTrace = 1;
          break;

          case 'd':
            startWithALoop = 1;
          break;

          default:
            // rely on compiler interface to check for errors
            break;
          }
    }

  if (doTrace)
  {
    printf("(%d) EVENT_LOG_READER calltype %d input %p\n", pid,
           (int) calltype, input_row);
    fflush(stdout);
  }

  if (udrinfo->num_return_values != 10)
    if (udrinfo->num_return_values == 13)
      addFileColumns = 1;
    else
        {
          strcpy(sqlstate, "38000");
          snprintf(msgtext,
                   SQLUDR_MSGTEXT_SIZE,
                   "Expecting 10 or 13 result columns, got %d",
                   udrinfo->num_return_values);
          return SQLUDR_ERROR;
        }

  // the output parameters
  SQLUDR_PARAM *log_ts_param        = &(udrinfo->return_values[0]);
  SQLUDR_PARAM *severity_param      = &(udrinfo->return_values[1]);
  SQLUDR_PARAM *component_param     = &(udrinfo->return_values[2]);
  SQLUDR_PARAM *node_number_param   = &(udrinfo->return_values[3]);
  SQLUDR_PARAM *cpu_param           = &(udrinfo->return_values[4]);
  SQLUDR_PARAM *pin_param           = &(udrinfo->return_values[5]);
  SQLUDR_PARAM *process_name_param  = &(udrinfo->return_values[6]);
  SQLUDR_PARAM *sql_code_param      = &(udrinfo->return_values[7]);
  SQLUDR_PARAM *query_id_param      = &(udrinfo->return_values[8]);
  SQLUDR_PARAM *message_param       = &(udrinfo->return_values[9]);
  SQLUDR_PARAM *log_file_node_param = NULL;
  SQLUDR_PARAM *log_file_name_param = NULL;
  SQLUDR_PARAM *log_file_line_param = NULL;
  if (addFileColumns)
    {
      log_file_node_param = &(udrinfo->return_values[10]);
      log_file_name_param = &(udrinfo->return_values[11]);
      log_file_line_param = &(udrinfo->return_values[12]);
    }

  char *output_row = rowDataSpace2;

  // pointers of the appropriate type for the output
  char          *log_ts_param_ptr        = (char *) &(output_row[udrinfo->return_values[0].data_offset]);
  char          *severity_param_ptr      = (char *) &(output_row[udrinfo->return_values[1].data_offset]);
  char          *component_param_ptr     = (char *) &(output_row[udrinfo->return_values[2].data_offset]);
  SQLUDR_INT32  *node_number_param_ptr   = (SQLUDR_INT32 *) &(output_row[udrinfo->return_values[3].data_offset]);
  SQLUDR_INT32  *cpu_param_ptr           = (SQLUDR_INT32 *) &(output_row[udrinfo->return_values[4].data_offset]);
  SQLUDR_INT32  *pin_param_ptr           = (SQLUDR_INT32 *) &(output_row[udrinfo->return_values[5].data_offset]);
  char          *process_name_param_ptr  = (char *) &(output_row[udrinfo->return_values[6].data_offset]);
  SQLUDR_INT32  *sql_code_param_ptr      = (SQLUDR_INT32 *) &(output_row[udrinfo->return_values[7].data_offset]);
  SQLUDR_INT16  *query_id_param_len      = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[8].vc_ind_offset]);
  char          *query_id_param_ptr      = (char *) &(output_row[udrinfo->return_values[8].data_offset]);
  SQLUDR_INT16  *message_param_len       = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[9].vc_ind_offset]);
  char          *message_param_ptr       = (char *) &(output_row[udrinfo->return_values[9].data_offset]);
  SQLUDR_INT32  *log_file_node_param_ptr = NULL;
  SQLUDR_INT16  *log_file_name_param_len = NULL;
  char          *log_file_name_param_ptr = NULL;
  SQLUDR_INT32  *log_file_line_param_ptr = NULL;
  if (addFileColumns)
    {
      log_file_node_param_ptr = (SQLUDR_INT32 *) &(output_row[udrinfo->return_values[10].data_offset]);
      log_file_name_param_len = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[11].vc_ind_offset]);
      log_file_name_param_ptr = (char *) &(output_row[udrinfo->return_values[11].data_offset]);
      log_file_line_param_ptr = (SQLUDR_INT32 *) &(output_row[udrinfo->return_values[12].data_offset]);
    }

  // null indicators
  SQLUDR_INT16 *log_ts_param_ind        = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[0].ind_offset]);
  SQLUDR_INT16 *severity_param_ind      = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[1].ind_offset]);
  SQLUDR_INT16 *component_param_ind     = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[2].ind_offset]);
  SQLUDR_INT16 *node_number_param_ind   = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[3].ind_offset]);
  SQLUDR_INT16 *cpu_param_ind           = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[4].ind_offset]);
  SQLUDR_INT16 *pin_param_ind           = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[5].ind_offset]);
  SQLUDR_INT16 *process_name_param_ind  = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[6].ind_offset]);
  SQLUDR_INT16 *sql_code_param_ind      = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[7].ind_offset]);
  SQLUDR_INT16 *query_id_param_ind      = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[8].ind_offset]);
  SQLUDR_INT16 *message_param_ind       = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[9].ind_offset]);
  SQLUDR_INT16 *log_file_node_param_ind = NULL;
  SQLUDR_INT16 *log_file_name_param_ind = NULL;
  SQLUDR_INT16 *log_file_line_param_ind = NULL;
  if (addFileColumns)
    {
      log_file_node_param_ind = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[10].ind_offset]);
      log_file_name_param_ind = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[11].ind_offset]);
      log_file_line_param_ind = (SQLUDR_INT16 *) &(output_row[udrinfo->return_values[12].ind_offset]);
    }

  char inString[1024] = "";
  int inLen = 0;
  DIR *logDir = NULL;
  FILE *infile = NULL;
  struct dirent *dirEntry = NULL;
  int lineNumber = 0;           // line number in current file
  int status = 0;
  int columnNum = 0;
  int columnSequenceError = 0;   // error that prevents us from parsing further
  char inputLine[5000];          // space for all fields in character form
  char inputLineValidated[5000]; // inputLine after validation
  char *ok = NULL;               // status of fgets

  if (startWithALoop)
    {
      int i=1;

      while (i < 2)
        i = 1-i;
    }

  char* sqroot = getenv("MY_SQROOT");
  if (strlen(sqroot) > 1000)
  {
    strcpy(sqlstate, "38001");
    snprintf(msgtext, SQLUDR_MSGTEXT_SIZE, "SQROOT is longer than 1000 characters");
    return SQLUDR_ERROR;
  }

  std::string logDirName(sqroot);

  logDirName += "/logs";

  if (doTrace)
    {
      printf("(%d) EVENT_LOG_READER open log dir %s\n", pid, logDirName.data());
      fflush(stdout);
    }

  errno = 0;
  logDir = opendir(logDirName.data());
  if (logDir == NULL)
    {
      status = errno;
      strcpy(sqlstate, "38002");
      snprintf(msgtext, SQLUDR_MSGTEXT_SIZE, "Error %d on opening directory %s",
               status, logDirName.data());
      return SQLUDR_ERROR;
    }

  status = chdir(logDirName.data());

  if (status != 0)
    {
      strcpy(sqlstate, "38003");
      snprintf(msgtext, SQLUDR_MSGTEXT_SIZE, "Error %d on changing current directory to %s",
               status, logDirName.data());
      return SQLUDR_ERROR;
    }

  // initialize output row
  memset(output_row, 0, udrinfo->out_row_length);

  if (addFileColumns)
    {
      // log_file_node is the same for every row generated by this process
      *log_file_node_param_ptr = udrinfo->instance_current;
    }

  qstate = SQLUDR_Q_MORE;

  while (1)
  {
    // read the next file in the log directory

    errno = 0;
    struct dirent *dirEntry = readdir(logDir);

    if (errno != 0)
    {
      status = errno;
      strcpy(sqlstate, "38003");
      snprintf(msgtext, SQLUDR_MSGTEXT_SIZE, "Error %d on reading from directory %s",
               status, logDirName.data());
      return SQLUDR_ERROR;
    }

    // last file seen, we are done
    if (dirEntry == NULL)
      break;

    if (doTrace)
      {
        printf("(%d) EVENT_LOG_READER examining log file %s\n", pid, dirEntry->d_name);
        fflush(stdout);
      }

    // parse the file name to see whether this is a file we want to look at
    // right now, files we want to see are mxosrvr_*.log and tmf*.log
    if ((strstr(dirEntry->d_name, "mxosrvr_") == dirEntry->d_name ||
         strstr(dirEntry->d_name, "tmf") == dirEntry->d_name) &&
        strcmp(strstr(dirEntry->d_name, ".log"), ".log") == 0)
      {

        /* Open the input file */
        infile = fopen(dirEntry->d_name, "r");
        if (infile == NULL)
          {
            status = errno;
            strncpy(sqlstate, "38001", 6);
            snprintf(msgtext, SQLUDR_MSGTEXT_SIZE, "Error %d returned when opening log file %s",
                     status, dirEntry->d_name);
            return SQLUDR_ERROR;
          }

        if (doTrace)
          {
            printf("(%d) EVENT_LOG_READER fopen\n", pid);
            fflush(stdout);
          }

        if (addFileColumns)
          {
            // set file name output column (same for all lines of this file)
            setVarCharOutputColumn(log_file_name_param_ptr,
                                   log_file_name_param_len,
                                   log_file_name_param_ind,
                                   log_file_name_param,
                                   dirEntry->d_name);
          }

        lineNumber = 0;

        // Loop over the lines of the file
        while ((ok = fgets(inputLine, sizeof(inputLine), infile)) != NULL)
          {
            int year, month, day, hour, minute, second, fraction;
            char fractionSeparator[2];
            char *currField = inputLineValidated;
            char *nextField = NULL;
            char *messageTextField = NULL;
            int numChars = 0;
            int numItems = 0;
            int intFieldVal;
            int lineLength = strlen(inputLine);
            int lineLengthValidated = 0;

            lineNumber++;

            // skip any empty lines or lines obviously not in the right format,
            // should not really happen
            if (lineLength < 30)
              {
                if (doTrace)
                  {
                    printf("(%d) EVENT_LOG_READER read short line %s\n", pid, inputLine);
                    fflush(stdout);
                  }

                continue;
              }

            // remove a trailing LF character
            if (inputLine[lineLength-1] == '\n')
              {
                lineLength--;
                inputLine[lineLength] = 0;
              }
            else
              {
                // skip over any text in the same line that
                // didn't get read
                char extraChars[4000];
                char *extraStatus;
                do
                  {
                    extraStatus = fgets(extraChars, sizeof(extraChars), infile);
                  }
                while (extraStatus != NULL && extraChars[strlen(extraChars)-1] != '\n');

              }

            // validate UTF-8 characters in inputLine and copy
            // to inputLineValidated, replacing any invalid characters
            // with the "replacement character" U+FFFD
            int srcPos = 0;
            int tgtPos = 0;
            unsigned char c;
            int byte = 1;
            int tgtLimit = sizeof(inputLineValidated) - 4 - 1;

            while (srcPos < lineLength && tgtPos < tgtLimit)
              {
                c = inputLine[srcPos];
                
                if (c < 0x80)
                  {
                    // ASCII character
                    inputLineValidated[tgtPos++] = inputLine[srcPos++];
                  }
                else
                  {
                    // non-ASCII or invalid byte sequence
                    int numBytes;
                    int validUTF8Char = 1;

                    if (c >= 0xc0 && c < 0xe0) // start of 2-byte sequence
                      numBytes = 2;
                    else if (c >= 0xe0 && c < 0xf0) // start of 3-byte sequence
                      numBytes = 3;
                    else if (c >= 0xf0 && c < 0xfc) // start of 4-byte sequence
                      numBytes = 4;
                    else
                      {
                        // invalid sequence, remove those one by one
                        numBytes = 1;
                        validUTF8Char = 0;
                      }

                    if (numBytes > lineLength - srcPos)
                      validUTF8Char = 0; // incomplete sequence

                    // make sure we have numBytes continuation bytes following
                    // in the range of 0x80 ... 0xbf
                    for (int p=1; p<numBytes; p++)
                      {
                        unsigned char s = inputLine[srcPos+p];

                        if (s < 0x80 || s >= 0xc0)
                          validUTF8Char = 0;
                      }
                          
                    if (validUTF8Char)
                      {
                        for (int j=0; j<numBytes; j++)
                          inputLineValidated[tgtPos++] = inputLine[srcPos++];
                      }
                    else
                      {
                        // U+FFFD in UTF-8
                        const unsigned char replacementChar[] =
                          { 0xef, 0xbf, 0xbd };

                        for (int k=0; k<sizeof(replacementChar); k++)
                          inputLineValidated[tgtPos++] = (char) replacementChar[k];
                        srcPos += numBytes;

                        if (doTrace)
                          {
                            printf("(%d) EVENT_LOG_READER invalid %d byte UTF8 char %d in line %d\n",
                                   pid, numBytes, (int) inputLine[srcPos-numBytes], lineNumber);
                            fflush(stdout);
                          }
                      }
                  }
              }

            lineLengthValidated = tgtPos;
            inputLineValidated[lineLengthValidated] = 0;

            // read the timestamp at the beginning of the line. Example:
            // 2014-10-30 20:49:53,252
            numItems = sscanf(currField,
                              "%4d-%2d-%2d %2d:%2d:%2d %1[,.] %6d%n",
                              &year, &month, &day, &hour, &minute,
                              &second, fractionSeparator, &fraction, &numChars);

            if (numItems == 8)
              {
                // when we see a comma between time and fraction, we interpret
                // that as a fraction that is specified in milliseconds, convert
                // to microseconds. When it's specified with a dot, we interpret
                // the fraction as microseconds (SQL syntax).
                if (*fractionSeparator == ',')
                  fraction *= 1000;
                  
                sprintf(log_ts_param_ptr,
                        "%04d-%02d-%02d %02d:%02d:%02d.%06d",
                        year, month, day, hour, minute, second, fraction);
              }
            else
              {
                if (numItems > 6)
                  numItems = 6;

                if (doTrace)
                  {
                    printf("(%d) EVENT_LOG_READER Read only %d of 7 timestamp fields: %s\n",
                           pid, numItems, currField);
                    fflush(stdout);
                  }

                // return a NULL value if we fail to parse the timestamp
                *log_ts_param_ind = -1;
              }

            // skip over the information already read
            currField = currField + numChars;

            // skip over the comma
            currField = strstr(currField, ",");
            if (*currField)
              currField++;
            else
              {
                // did not find a comma delimiter, this is a parse
                // error, produce NULL values for remaining columns
                // except the message
                if (numChars > 0)
                  currField = inputLineValidated + (numChars-1);
                else
                  currField = inputLineValidated;
                *currField = 0;
                messageTextField =
                  (numChars < lineLengthValidated) ? currField+1 : currField;
              }

            // read columns 2: SEVERITY - 9: QUERY_ID
            for (columnNum = 2; columnNum <= 9; columnNum++)
              {
                // find the next comma, the end of our field value
                char *endOfField = strstr(currField, ",");
                char *startOfVal = NULL;
                
                if (endOfField != NULL)
                  {
                    startOfVal = (endOfField != currField ? endOfField-1 : currField);

                    // next field starts after the comma
                    nextField = endOfField + 1;

                    // back up before the trailing comma, if the value is not empty
                    if (endOfField != currField)
                      endOfField--;

                    // remove trailing blanks
                    while (*endOfField == ' ')
                      endOfField--;

                    // place a nul-terminator at the end of the field
                    // (this overwrites the comma or a trailing blank)
                    if (endOfField != currField)
                      endOfField[1] = 0;
                    else
                      endOfField[0] = 0; // empty field

                    // from the end, go back to the preceding ":" or ","
                    // or until we reach the start of the current field
                    // This way, we skip field names like "CPU:" in CPU: 3
                    while (*startOfVal != ':' &&
                           *startOfVal != ',' &&
                           startOfVal != currField)
                      startOfVal--;

                    // skip the ":"
                    if (startOfVal != currField)
                      startOfVal++;

                    // skip leading blanks
                    while (*startOfVal == ' ')
                      startOfVal++;
                  } // found a comma delimiter
                else
                  {
                    // Did not find a comma delimiter. This could be a
                    // parse error or a missing optional column,
                    // produce NULL values for remaining columns
                    // except the message
                    if (currField != inputLineValidated)
                      // back up, since currField is now pointing
                      // at the first character of the message text
                      currField--;
                    *currField = 0;
                    startOfVal = currField;
                    nextField = currField;
                    // if there is any text left, point to it
                    // (after currField, which points to a NUL byte)
                    // otherwise set the message text field to an empty string
                    if (messageTextField == NULL)
                      messageTextField =
                        (currField-inputLineValidated < lineLengthValidated) ?
                        currField+1 : currField;
                  }

                // now that we have the non-blank portion of the value,
                // copy it into the output column
                switch (columnNum)
                  {
                  case 2:
                    setCharOutputColumn(severity_param_ptr,
                                        severity_param_ind,
                                        severity_param,
                                        startOfVal);
                    break;

                  case 3:
                    setCharOutputColumn(component_param_ptr,
                                        component_param_ind,
                                        component_param,
                                        startOfVal);
                    break;

                  case 4:
                    setIntOutputColumn(node_number_param_ptr,
                                       node_number_param_ind,
                                       startOfVal);
                    break;

                  case 5:
                    setIntOutputColumn(cpu_param_ptr,
                                       cpu_param_ind,
                                       startOfVal);
                    break;

                  case 6:
                    setIntOutputColumn(pin_param_ptr,
                                       pin_param_ind,
                                       startOfVal);
                    break;

                  case 7:
                    setCharOutputColumn(process_name_param_ptr,
                                        process_name_param_ind,
                                        process_name_param,
                                        startOfVal);
                    break;

                  case 8:
                    setIntOutputColumn(sql_code_param_ptr,
                                       sql_code_param_ind,
                                       startOfVal);
                    break;

                  case 9:
                    setVarCharOutputColumn(query_id_param_ptr,
                                           query_id_param_len,
                                           query_id_param_ind,
                                           query_id_param,
                                           startOfVal);
                    // we read all required fields,
                    // next field is the message text
                    if (messageTextField == NULL)
                      messageTextField = nextField;
                    break;
                  }

                currField = nextField;
              } // loop over column numbers 2-9

            // now we reached the last field in the file, the message text itself
            while (*messageTextField == ' ')
              messageTextField++;

            setVarCharOutputColumn(message_param_ptr,
                                   message_param_len,
                                   message_param_ind,
                                   message_param,
                                   messageTextField);

            if (addFileColumns)
              {
                // line number column is computed, not from the log file
                *log_file_line_param_ptr = lineNumber;
              }
            

            /* Emit a row */
            emitRow(output_row, 0, &qstate);
            if (doTrace)
              {
                printf("(%d) EVENT_LOG_READER emit\n", pid);
                fflush(stdout);
              }
          } // loop over the lines of the file

        /* Close the input file */
        if (infile)
          fclose(infile);
        if (doTrace)
          {
            printf("(%d) EVENT_LOG_READER fclose\n", pid);
            fflush(stdout);
          }
      } // file name matched our pattern
  } // while (1) - list files in the directory

  /* Emit EOD */
  qstate = SQLUDR_Q_EOD;
  emitRow(output_row, 0, &qstate);
  if (doTrace)
  {
    printf("(%d) EVENT_LOG_READER emit EOD\n", pid);
    fflush(stdout);
  }
  
  return SQLUDR_SUCCESS;
}

// compiler interface class for TRAF_CPP_EVENT_LOG_READER

class ReadCppEventsUDFInterface : public TMUDRInterface
{
  // override any methods where the UDF author would
  // like to change the default behavior

  virtual void describeParamsAndColumns(UDRInvocationInfo &info); // Binder
  virtual void describeDesiredDegreeOfParallelism(UDRInvocationInfo &info,
                                                  UDRPlanInfo &plan);// Optimizer

private:
  bool useParallelExecForVirtualNodes_;

};

extern "C" TMUDRInterface * TRAF_CPP_EVENT_LOG_READER_CreateCompilerInterfaceObject(
     const UDRInvocationInfo *info)
{
  return new ReadCppEventsUDFInterface();
}

void ReadCppEventsUDFInterface::describeParamsAndColumns(
     UDRInvocationInfo &info)
{
  bool addFileColumns = false;

  useParallelExecForVirtualNodes_ = false;

  // This UDF is a table-valued function, no table-valued inputs
  if (info.getNumTableInputs() != 0)
    throw UDRException(38220,
                       "There should be no table-valued parameters to the call to %s, got %d",
                       info.getUDRName().data(),
                       info.getNumTableInputs());

  if (info.getNumActualParameters() > 1)
    throw UDRException(38221,
                       "There should be no more than one input parameters to the call to %s, got %d",
                       info.getUDRName().data(),
                       info.getNumActualParameters());
  else if (info.getNumActualParameters() == 1)
    {
      const tmudr::ParameterInfo &firstParam = info.getActualParameterInfo(0);

      if (firstParam.isAvailable() != tmudr::ParameterInfo::STRING_VALUE)
        throw UDRException(38222,
                           "Expecting a character constant as first parameter of the call to %s",
                           info.getUDRName().data());

      const char *options = firstParam.getStringValue();

      // add an additional formal parameter for the options value
      info.addFormalParameter(ParameterInfo("OPTIONS",
                                            firstParam.getType()));

      // validate options
      while (*options)
        {
          switch (*options)
            {
            case 'f':
              addFileColumns = true;
            break;

            case 't':
              // trace option, handled at runtime
            break;

            case ' ':
              // tolerate blanks in the options
              break;

#ifndef NDEBUG
            case 'd':
              // debug option, makes UDF loop at runtime to attach
              // debugger
              break;
            case 'p':
              // debug option, use parallel execution even with virtual nodes
              useParallelExecForVirtualNodes_ = true;
              break;
#endif

            default:
              {
                throw UDRException(38223,
                                   "Option %c not supported in first parameter of the call to %s",
                                   *options,
                                   info.getUDRName().data());
              }
              
            }
          options++;
        }
    } // got 1 input parameter

  // add the output columns
  TableInfo &outTable = info.getOutputTableInfo();

  outTable.addColumn(
       ColumnInfo("LOG_TS",
                  TypeInfo(TypeInfo::TIMESTAMP,
                           0,
                           true,
                           6)));
  outTable.addCharColumn   ("SEVERITY",    10, true);
  outTable.addCharColumn   ("COMPONENT",   24, true);
  outTable.addIntegerColumn("NODE_NUMBER",     true);
  outTable.addIntegerColumn("CPU",             true);
  outTable.addIntegerColumn("PIN",             true);
  outTable.addCharColumn   ("PROCESS_NAME",12, true);
  outTable.addIntegerColumn("SQL_CODE",        true);
  outTable.addVarCharColumn("QUERY_ID",   200, true);
  outTable.addVarCharColumn("MESSAGE",   4000, true);

  if (addFileColumns)
    {
      outTable.addIntegerColumn("LOG_FILE_NODE");
      outTable.addVarCharColumn("LOG_FILE_NAME",200);
      outTable.addIntegerColumn("LOG_FILE_LINE");
    }
}

void ReadCppEventsUDFInterface::describeDesiredDegreeOfParallelism(
     UDRInvocationInfo &info,
     UDRPlanInfo &plan)
{
  // check for configurations with virtual nodes. Run the UDF serially
  // in those cases, since all the virtual nodes share the same node.
  int usesNoVirtualNodes = system("grep '^_virtualnodes ' $MY_SQROOT/sql/scripts/sqconfig >/dev/null");

  if (usesNoVirtualNodes != 0 || useParallelExecForVirtualNodes_)
    // this TMUDF needs to run once on each node, since every
    // parallel instance will be reading the local files on that node
    plan.setDesiredDegreeOfParallelism(UDRPlanInfo::ONE_INSTANCE_PER_NODE);
  else
    plan.setDesiredDegreeOfParallelism(1);
}
