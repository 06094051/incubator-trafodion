#!/usr/bin/python -tt

# @@@ START COPYRIGHT @@@
#
# (C) Copyright 2014-2015 Hewlett-Packard Development Company, L.P.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
# @@@ END COPYRIGHT @@@

import os
import sys
import tempfile
import re
import logging
import subprocess
import string
from optparse import OptionParser

# exit codes
EXIT_SUCCESS       = 0 # Success
EXIT_GENERAL_ERROR = 1 # One or more errors encountered (invalid arguments, prerequisites not satisfied, can't execute check command, etc)
EXIT_CHECK_ERROR   = 2 # At least one check failed with error severity (required configuration)
EXIT_CHECK_WARNING = 3 # At least one check failed with warning severity (recommended configuration) and no checks failed with error severity

def configure_trafodion_scanner_logger(log_file):
  logger = logging.getLogger("trafodion_scanner_logger")
  logger.setLevel(logging.DEBUG)
  formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
  fh = logging.FileHandler(log_file)
  fh.setLevel(logging.DEBUG)
  fh.setFormatter(formatter)
  logger.addHandler(fh)
  return logger
  
def compare_check_result(result, expected_result, comparison_operator):
  # for the comparison operators (str_lt, str_le, str_eq, str_ne, str_ge, str_gt),
  # we first cast the result and expected_result to string type, to enable correct comparison
  if (comparison_operator.startswith('str_')):
    result = str(result); expected_result = str(expected_result)  
  
  # for the comparison operators (int_lt, int_le, int_eq, int_ne, int_ge, int_gt),
  # we first cast the result and expected_result to integer type, to enable correct comparison  
  if (comparison_operator.startswith('int_')):
    result = int(result); expected_result = int(expected_result)

  if (comparison_operator.endswith('lt')):
    return expected_result < result
  if (comparison_operator.endswith('le')):
    return expected_result <= result
  if (comparison_operator.endswith('eq')):
    return expected_result == result
  if (comparison_operator.endswith('ne')):
    return expected_result != result
  if (comparison_operator.endswith('ge')):
    return expected_result >= result
  if (comparison_operator.endswith('gt')):
    return expected_result > result

def exec_command(cmd_string):
  temp_file=tempfile.TemporaryFile()
  exit_code = subprocess.call(cmd_string, stdout=temp_file, stderr=subprocess.STDOUT, shell=True)
  temp_file.seek(0) # go back to start of file before read
  cmd_output = temp_file.read()
  cmd_output = cmd_output.strip() # trim leading and trailing whitespace
  return (cmd_output, exit_code)
  
def exec_command_remote(cmd_string, node_name):
  named_temp_file=tempfile.NamedTemporaryFile(delete=False)
  named_temp_file.write(cmd_string)
  named_temp_file.close()
  cmd = 'cat ' + named_temp_file.name + ' | ssh -oStrictHostKeyChecking=no -oBatchMode=yes -q -T ' + node_name
  (cmd_output, exit_code) = exec_command(cmd)
  os.remove(named_temp_file.name)
  return (cmd_output, exit_code)    
  
def read_config(filename):
  with open(filename, 'r') as config:
    logger = logging.getLogger("trafodion_scanner_logger")
    logger.info("Reading configuration file %s", filename)
    lines = []
    for line in config:
      if re.search('^#', line) or re.search('^\s*$', line): # skip comments and blank lines
        continue
      elif re.search(':::', line): # configuration line
        lines.append(line.split(':::'))
      elif len(lines) > 0: # multi-line command, append to the command in the last configuration line
        lines[-1][-1] += line
      else: # unexpected line, raise an error and exit
        err_str = 'Fatal error: encountered unexpected line in configuration file: %s' % (line)
        logger.error(err_str); print(err_str)
        sys.exit(EXIT_GENERAL_ERROR)
    return lines

def replace_placeholders_in_command_string(cmd_string, placeholder_map):
  new_cmd_string = cmd_string
  for placeholder in placeholder_map:
    new_cmd_string = new_cmd_string.replace(placeholder, placeholder_map[placeholder])
  return new_cmd_string
  
def validate_severity_level(severity_level, operation, name):
  if (severity_level not in ('error', 'warning')):
    err_str = 'Fatal error: invalid severity level "%s" ' % (severity_level)
    err_str += 'specified for %s operation "%s". Exiting.' % (operation, name)
    logger = logging.getLogger("trafodion_scanner_logger")
    logger.error(err_str); print(err_str)
    sys.exit(EXIT_GENERAL_ERROR)  
  
def validate_comparison_operator(comparison_operator, operation, name):
  if (comparison_operator not in ('str_lt', 'str_le', 'str_eq', 'str_ne', 'str_ge', 'str_gt') and
      comparison_operator not in ('int_lt', 'int_le', 'int_eq', 'int_ne', 'int_ge', 'int_gt')):
    err_str = 'Fatal error: invalid comparison operator "%s" ' % (comparison_operator)
    err_str += 'specified for %s operation "%s". Exiting.' % (operation, name)
    logger = logging.getLogger("trafodion_scanner_logger")
    logger.error(err_str); print(err_str)
    sys.exit(EXIT_GENERAL_ERROR) 
      
# This function will return a dictionary that's keyed by the distinct set of the input strings.
# The value for each key will be the list of node names associated with each distinct input string.
# Example: 
#   INPUT:
#     list_of_node_names = ['n001', 'n002', 'n003', 'n004']
#     map_of_strings_by_node_name = {'n001': 'hello', 'n002': 'hi there', 'n003': 'hello', 'n004': 'goodbye'}
#   OUTPUT:
#     node_grouping = {'hello': ['n001', 'n003'], 'hi there': ['n002'], 'goodbye': ['n004']}
def group_nodes_by_string(list_of_node_names, map_of_strings_by_node_name):
  node_grouping = {}
  for node_name in list_of_node_names:
    string_for_node = map_of_strings_by_node_name[node_name]
    if string_for_node in node_grouping:
      node_grouping[string_for_node].append(node_name)
    else:
      node_grouping[string_for_node] = [node_name]
  return node_grouping
 
def check_passwordless_ssh_and_sudo_access(list_of_node_names, execute_local_commands_flag):
  logger = logging.getLogger("trafodion_scanner_logger")
  count_of_nodes = len(list_of_node_names)
  count_of_inaccessible_nodes = 0
  count_of_nodes_without_sudo_access = 0
  count_of_nodes_with_error = 0
  for node_name in list_of_node_names:
    if (not execute_local_commands_flag):
      cmd = 'echo "sudo -n echo test >/dev/null" | ssh -oStrictHostKeyChecking=no -oBatchMode=yes -T ' + node_name
    else:
      cmd = 'sudo -n echo test >/dev/null'
    (cmd_output, exit_code) = exec_command(cmd)
    # ssh exits with 255 if an ssh-related error occurred, otherwise with the exit status of the remote command
    if exit_code == 255: 
      count_of_inaccessible_nodes += 1
      err_str = '***ERROR: Unable to access %s via passwordless ssh: %s' % (node_name, cmd_output)
      logger.error(err_str); print(err_str)
    # sudo exits with 1 if there is a configuration/permission problem
    elif exit_code == 1: 
      count_of_nodes_without_sudo_access += 1
      if 'must have a tty to run sudo' in cmd_output:
        err_str = '***ERROR: sudo access is not correctly configured for the user running this script '
        err_str += 'on node %s: requiretty must be disabled for this user in /etc/sudoers.' % (node_name)
        logger.error(err_str); print(err_str)
      else:
        err_str = '***ERROR: sudo access is not enabled for the user running this script '
        err_str += 'on node %s: this script must be run by a user with full sudo access.' % (node_name)
        logger.error(err_str); print(err_str)
    # unexpected error encountered
    elif exit_code != 0:
      count_of_nodes_with_error += 1
      err_str = '***ERROR: could not check passwordless ssh and/or sudo access on node %s.' % (node_name)
      err_str += '\nError details: command executed: %s, exit code: %d, output: %s' % (cmd, exit_code, cmd_output)
      logger.error(err_str); print(err_str)
  if count_of_inaccessible_nodes > 0:
    err_str = 'Fatal error: unable to access %d of %d ' % (count_of_inaccessible_nodes, count_of_nodes)
    err_str += 'specified nodes via passwordless ssh.'
    logger.error(err_str); print(err_str)
  if count_of_nodes_without_sudo_access > 0:
    err_str = 'Fatal error: sudo access is not enabled and/or correctly configured for the user running '
    err_str += 'this script on %d of %d specified nodes.' % (count_of_nodes_without_sudo_access, count_of_nodes)
    logger.error(err_str); print(err_str)
  if count_of_nodes_with_error > 0:
    err_str = 'Fatal error: could not check passwordless ssh and/or sudo access on '
    err_str += '%d of %d specified nodes.' % (count_of_nodes_with_error, count_of_nodes)
    logger.error(err_str); print(err_str)       
  if count_of_inaccessible_nodes > 0 or count_of_nodes_without_sudo_access > 0 or count_of_nodes_with_error > 0:
    err_str = 'Exiting due to fatal error(s).'
    logger.error(err_str); print(err_str)
    sys.exit(EXIT_GENERAL_ERROR)  
    
def check_hadoop_distribution(list_of_node_names, execute_local_commands_flag):
  logger = logging.getLogger("trafodion_scanner_logger")
  count_of_nodes = len(list_of_node_names)
  count_of_nodes_with_multiple = 0
  count_of_nodes_with_none = 0
  count_of_nodes_with_error = 0
  count_of_nodes_with_ambari = 0
  count_of_nodes_with_cloudera = 0
  cmd_string1 = "rpm -qa 'ambari*' | grep -q 'ambari' 2>&1"
  cmd_string2 = "rpm -qa 'cloudera*' | grep -q 'cloudera' 2>&1"
  hadoop_type = ''
  for node_name in list_of_node_names:
    node_hadoop_type = ''
    if (not execute_local_commands_flag):
      (cmd_output1, exit_code1) = exec_command_remote(cmd_string1, node_name)
      (cmd_output2, exit_code2) = exec_command_remote(cmd_string2, node_name)
    else:
      (cmd_output1, exit_code1) = exec_command(cmd_string1)
      (cmd_output2, exit_code2) = exec_command(cmd_string2)    
    if exit_code1 == 0: 
      node_hadoop_type = 'ambari'
      count_of_nodes_with_ambari += 1
    if exit_code2 == 0: 
      node_hadoop_type = 'cloudera'
      count_of_nodes_with_cloudera += 1
    if exit_code1 == 0 and exit_code2 == 0: 
      node_hadoop_type = 'both'
      count_of_nodes_with_multiple += 1
      err_str = '***ERROR: detected multiple Hadoop distributions (Ambari and Cloudera) '
      err_str += 'on node %s. Only one is allowed.' % (node_name)
      logger.error(err_str); print(err_str)
    if exit_code1 == 1 and exit_code2 == 1:
      node_hadoop_type = 'none'
      count_of_nodes_with_none += 1
      err_str = '***ERROR: no Hadoop distribution detected '
      err_str += 'on node %s. Please install one.' % (node_name)
      logger.error(err_str); print(err_str)
    if node_hadoop_type == '':
      node_hadoop_type = 'error'
      count_of_nodes_with_error += 1
      err_str = '***ERROR: could not determine the Hadoop distribution type '
      err_str += 'on node %s.' % (node_name)
      if exit_code1 > 1:
        err_str += '\nError details: command executed: '
        err_str += '%s, exit code: %d, output: %s' % (cmd_string1, exit_code1, cmd_output1)
      if exit_code2 > 1:
        err_str += '\nError details: command executed: '
        err_str += '%s, exit code: %d, output: %s' % (cmd_string2, exit_code2, cmd_output2)      
      logger.error(err_str); print(err_str)
    hadoop_type = node_hadoop_type
  if count_of_nodes_with_none > 0:
    err_str = 'Fatal error: no Hadoop distribution detected on '
    err_str += '%d of %d specified nodes.' % (count_of_nodes_with_none, count_of_nodes)
    logger.error(err_str); print(err_str)
  if count_of_nodes_with_multiple > 0:
    err_str = 'Fatal error: detected multiple Hadoop distributions (Ambari and Cloudera) on '
    err_str += '%d of %d specified nodes.' % (count_of_nodes_with_multiple, count_of_nodes)
    logger.error(err_str); print(err_str)
  if count_of_nodes_with_ambari > 0 and count_of_nodes_with_cloudera > 0:
    err_str = 'Fatal error: detected mixed Hadoop distributions (Ambari and Cloudera): '
    err_str += '%d of %d specified nodes have Ambari and ' % (count_of_nodes_with_ambari, count_of_nodes)
    err_str += '%d of %d specified nodes have Cloudera.' % (count_of_nodes_with_cloudera, count_of_nodes)    
    logger.error(err_str); print(err_str)  
  if count_of_nodes_with_error > 0:
    err_str = 'Fatal error: could not determine the Hadoop distribution type on '
    err_str += '%d of %d specified nodes.' % (count_of_nodes_with_error, count_of_nodes)
    logger.error(err_str); print(err_str)    
  if (count_of_nodes_with_none > 0 or count_of_nodes_with_multiple > 0 or count_of_nodes_with_error > 0
     or (count_of_nodes_with_ambari > 0 and count_of_nodes_with_cloudera > 0)):
    err_str = 'Exiting due to fatal error(s).'
    logger.error(err_str); print(err_str)
    sys.exit(EXIT_GENERAL_ERROR)
  return hadoop_type
      
def main(argv):
  parser = OptionParser()                
  parser.add_option("-n", "--nodes", dest="nodes", 
                    help="Blank-separated list of nodes (enclosed in quotes) on which you plan to "\
                    "install Trafodion. The trafodion scanner will check these nodes. These must be "\
                    "DNS names on your cluster. IP addresses are not supported. "\
                    "Example: --nodes \"node1 node2 node3 node4\". This is a required option.")
  parser.add_option("-c", "--config_file", dest="config_file", 
                    help="Trafodion Scanner configuration filename. Default is ./trafodion_scanner.cfg.", 
                    default="./trafodion_scanner.cfg")
  parser.add_option("-l", "--log_file", dest="log_file", 
                    help="Trafodion Scanner log filename. Default is ./trafodion_scanner.log.", 
                    default="./trafodion_scanner.log")                          
  parser.add_option("-o", "--single_operation", dest="single_operation", 
                    help="Execute a single operation from the Trafodion Scanner configuration file. "\
                    "The operation must be specified by name. This option can be used for operations "\
                    "of type CHECK_CONFIG and COMPARE_CONFIG. Example: --single_operation \"MinNumCores\".")
  parser.add_option("-p", "--skip_prerequisite_checks", dest="skip_prerequisite_checks", action='store_true',
                    help="This special option causes the Trafodion Scanner to skip the prerequisite checks "\
                    "that are normally executed at the beginning: passwordless ssh access checks, sudo access "\
                    "checks, and Hadoop distribution checks. This option is especially useful in combination "\
                    "with the --single_operation (-o) option.", 
                    default=False)
  parser.add_option("-x", "--execute_local_commands", dest="execute_local_commands", action='store_true',
                    help="This special option causes the Trafodion Scanner to execute all commands in a local "\
                    "shell rather than via ssh. Accordingly, the passwordless ssh access prerequisite check "\
                    "is skipped. This option is especially useful for unit testing on a single node, "\
                    "e.g., on a development workstation. With this option, the --nodes (-n) option will "\
                    "be ignored; it will be automatically set to \"localhost\".",
                    default=False)
  (options, args) = parser.parse_args()    
    
  # for convenience, set flag variables based on some of the options
  single_operation_flag = False if ((options.single_operation is None) or (len(options.single_operation.strip()) == 0)) else True
  skip_prerequisite_checks_flag = True if options.skip_prerequisite_checks == True else False
  execute_local_commands_flag = True if options.execute_local_commands == True else False
    
  # validate and process the --nodes (-n) option 
  if (not execute_local_commands_flag):
    if ((options.nodes is None) or (len(options.nodes.strip()) == 0)):
      print '\n***ERROR: The --nodes (-n) option is required!\n'
      parser.print_help()
      sys.exit(EXIT_GENERAL_ERROR)
    list_of_node_names = sorted(options.nodes.split())
    for node_name in list_of_node_names:  
      if (re.search('[^a-zA-Z0-9\.\-]', node_name)):
        print '\n***ERROR: Special characters cannot be specified for the --nodes (-n) option! '\
              'The only allowed characters are: lowercase letters (a-z), '\
              'uppercase letters (A-Z), digits (0-9), ".", and "-".\n'
        parser.print_help()
        sys.exit(EXIT_GENERAL_ERROR)
      elif (re.search('^([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})$', node_name)):
        print '\n***ERROR: IP addresses cannot be specified for the --nodes (-n) option!\n'
        parser.print_help()
        sys.exit(EXIT_GENERAL_ERROR)
  else:
    list_of_node_names = ['localhost']
  count_of_nodes = len(list_of_node_names)    
    
  try:
    logger = configure_trafodion_scanner_logger(options.log_file)
  except IOError as e:
    print 'Fatal error: cannot open log file "%s": %s\nExiting.' % (options.log_file, e.strerror)
    sys.exit(EXIT_GENERAL_ERROR)  
  
  logger.info('Started')  
  logger.info('Using the following options: --nodes="%s", --config_file="%s", --log_file="%s", '\
              '--single_operation="%s", --skip_prerequisite_checks="%s", --execute_local_commands="%s"',
              'localhost' if execute_local_commands_flag else options.nodes, 
              options.config_file, options.log_file, options.single_operation, 
              options.skip_prerequisite_checks, options.execute_local_commands)
  
  # special variable placeholders and their values, for replacement in the command strings
  placeholder_map = {}
  
  # severity level for each CHECK_CONFIG and COMPARE_CONFIG operation (by name), for summary info reporting
  severity_map = {}
  
  # execute the prerequisite checks
  if (not skip_prerequisite_checks_flag): 
    info_str = 'Executing prerequisite checks. This may take several minutes ...'
    logger.info(info_str); print(info_str)  
  
    # before doing any checks, we first validate that we can access the specified nodes via passwordless ssh
    # and that the userid running this script has full sudo access (required for some of the scanner checks 
    # and also for the Trafodion installation)
    check_passwordless_ssh_and_sudo_access(list_of_node_names, execute_local_commands_flag)
  
    # also we need to validate that a single Hadoop distribution is installed on all the nodes
    hadoop_distribution = check_hadoop_distribution(list_of_node_names, execute_local_commands_flag)

    info_str = 'Prerequisite checks completed.'
    logger.info(info_str); print(info_str)  
  else:
    hadoop_distribution = 'undefined'
  placeholder_map['<<<hadoop_distribution>>>'] = hadoop_distribution
    
  num_RECORD_CONFIG_operations_done = 0
  num_CHECK_CONFIG_operations_done = 0 
  num_COMPARE_CONFIG_operations_done = 0   
  check_exit_code = EXIT_SUCCESS
  
  check_failures_per_node = {}
  for node_name in list_of_node_names:
    check_failures_per_node[node_name] = []
    
  try:
    scan_lines=read_config(options.config_file)
  except IOError as e:
    err_str = 'Fatal error: cannot open configuration file "%s": %s\nExiting.' % (options.config_file, e.strerror)
    logger.error(err_str); print(err_str)
    sys.exit(EXIT_GENERAL_ERROR)
  
  for i in range(len(scan_lines)):
    operation = scan_lines[i][0].strip() # trim leading and trailing whitespace
    
    # RECORD_CONFIG ::: <description> ::: <command>
    if (operation == 'RECORD_CONFIG'):
      descripion = scan_lines[i][1].strip() # trim leading and trailing whitespace
      command_string = scan_lines[i][2].strip() # trim leading and trailing whitespace
      
      # special logic for the --single_operation (-o) option
      if (single_operation_flag):
        continue
      
      num_RECORD_CONFIG_operations_done += 1
      
      # before command execution, we need to replace the special variable placeholders 
      # in the command string with the corresponding values
      command_string = replace_placeholders_in_command_string(command_string, placeholder_map)      
      
      for node_name in list_of_node_names:  
        if (not execute_local_commands_flag):
          (command_output, exit_code) = exec_command_remote(command_string, node_name)                   
        else:
          (command_output, exit_code) = exec_command(command_string)          

        logger.info('Configuration Recorded on node %s: %s: command executed: "%s", command output:\n%s\n', 
                    node_name, descripion, command_string, command_output)
        print 'Configuration Recorded on node ' + node_name + ': ' + string.ljust(descripion, 59) + '(see log)'

    # CHECK_CONFIG ::: <name> ::: <description> ::: <severity level> ::: <expected value> ::: <comparison operator> ::: <command>
    elif (operation == 'CHECK_CONFIG'):
      name = scan_lines[i][1].strip() # trim leading and trailing whitespace
      descripion = scan_lines[i][2].strip() # trim leading and trailing whitespace
      severity_level = scan_lines[i][3].strip() # trim leading and trailing whitespace
      expected_value = scan_lines[i][4].strip() # trim leading and trailing whitespace
      comparison_operator = scan_lines[i][5].strip() # trim leading and trailing whitespace
      command_string = scan_lines[i][6].strip() # trim leading and trailing whitespace

      # special logic for the --single_operation (-o) option
      if (single_operation_flag and options.single_operation.strip() != name):
        continue
      
      num_CHECK_CONFIG_operations_done += 1
      
      # validate the severity_level
      validate_severity_level(severity_level, operation, name)
            
      # record severity level for summary info reporting
      severity_map[name] = severity_level      
            
      # validate the comparison_operator
      validate_comparison_operator(comparison_operator, operation, name)
  
      # before command execution, we need to replace the special variable placeholders 
      # in the command string with the corresponding values
      command_string = replace_placeholders_in_command_string(command_string, placeholder_map)
  
      for node_name in list_of_node_names:
        if (not execute_local_commands_flag):
          (command_output, exit_code) = exec_command_remote(command_string, node_name)                   
        else:
          (command_output, exit_code) = exec_command(command_string)          

        try:
          compare_outcome = compare_check_result(command_output, expected_value, comparison_operator)
        except ValueError:           
          compare_outcome = False
          
        if (compare_outcome):
          check_outcome = "PASSED"
        else:
          check_outcome = "FAILED [%s]" % (severity_level)
          check_failures_per_node[node_name].append(name)
          if severity_level == 'error' and (check_exit_code == EXIT_SUCCESS or check_exit_code == EXIT_CHECK_WARNING):
            check_exit_code = EXIT_CHECK_ERROR
          elif severity_level == 'warning' and (check_exit_code == EXIT_SUCCESS):
            check_exit_code = EXIT_CHECK_WARNING
            
        detail_str = '   EXECUTION DETAILS: command executed: "%s", command output: "%s"\n' % (command_string, command_output)
        detail_str += '   EXPECTED RESULT: <expected value> <comparison operator> <command output>: '
        detail_str += '"%s" %s "%s" --> ' % (expected_value, comparison_operator, command_output)
        detail_str += 'condition satisfied' if check_outcome == "PASSED" else 'condition not satisfied'
        logger.info('Configuration Checked on node %s: %s: %s: %s\n%s\n', 
                    node_name, name, descripion, check_outcome, detail_str)
        print 'Configuration Checked on node ' + node_name + ': ' + string.ljust(descripion, 60) + ':' + check_outcome
        
    # COMPARE_CONFIG ::: <name> ::: <description> ::: <severity level> ::: <command>    
    elif (operation == 'COMPARE_CONFIG'):
      name = scan_lines[i][1].strip() # trim leading and trailing whitespace
      descripion = scan_lines[i][2].strip() # trim leading and trailing whitespace
      severity_level = scan_lines[i][3].strip() # trim leading and trailing whitespace
      command_string = scan_lines[i][4].strip() # trim leading and trailing whitespace

      # special logic for the --single_operation (-o) option
      if (single_operation_flag and options.single_operation.strip() != name):
        continue
      
      num_COMPARE_CONFIG_operations_done += 1
      
      # validate the severity_level
      validate_severity_level(severity_level, operation, name)
            
      # record severity level for summary info reporting
      severity_map[name] = severity_level
    
      # before command execution, we need to replace the special variable placeholders 
      # in the command string with the corresponding values
      command_string = replace_placeholders_in_command_string(command_string, placeholder_map)    
    
      if (not execute_local_commands_flag):
        node_output_map = {}
        for node_name in list_of_node_names:
          (command_output, exit_code) = exec_command_remote(command_string, node_name)
          node_output_map[node_name] = command_output
        output_node_grouping = group_nodes_by_string(list_of_node_names, node_output_map)  
        if (len(output_node_grouping) == 1):
          # there is only one item in the output_node_grouping dictionary, 
          # which means that all nodes had the same command ouput
          check_outcome = "PASSED"
        else:
          check_outcome = "FAILED [%s]" % (severity_level)
          # this check failed for all the nodes because they were found to be inconsistent
          for node_name in list_of_node_names:
            check_failures_per_node[node_name].append(name)
          if severity_level == 'error' and (check_exit_code == EXIT_SUCCESS or check_exit_code == EXIT_CHECK_WARNING):
            check_exit_code = EXIT_CHECK_ERROR
          elif severity_level == 'warning' and (check_exit_code == EXIT_SUCCESS):
            check_exit_code = EXIT_CHECK_WARNING
      else:
        check_outcome = "PASSED"
    
      detail_str = '   EXECUTION DETAILS: command executed on each node: "%s"\n' % (command_string)
      detail_str += '   EXPECTED RESULT: all nodes produce the same output\n'
      detail_str += '   ACTUAL RESULT: '
      if (check_outcome == "PASSED"):
        if (execute_local_commands_flag):
          detail_str += 'not applicable with the --execute_local_commands (-x) option'
        else:
          detail_str += 'all nodes produced the same output: %s\n' % (output_node_grouping.keys().pop())
      else:
        detail_str += 'nodes produced different output: \n'        
        for node_output_string in output_node_grouping:
          detail_str += '      ' + ', '.join(output_node_grouping[node_output_string]) + ': ' + node_output_string + '\n'     
      logger.info('Consistency Checked among all nodes: %s: %s: %s\n%s\n', name, descripion, check_outcome, detail_str)
      print 'Consistency Checked among all nodes' + ': ' + string.ljust(descripion, 59) + ':' + check_outcome 
      
    # unexpected operation type
    else:
      err_str = 'Fatal error: invalid operation type "%s" specified. Exiting.' % (operation)
      logger.error(err_str); print(err_str)
      sys.exit(EXIT_GENERAL_ERROR)  

  # special logic for the --single_operation (-o) option
  if (single_operation_flag and (num_CHECK_CONFIG_operations_done == 0 and num_COMPARE_CONFIG_operations_done == 0)):
      err_str = 'Fatal error: invalid operation name "%s" specified ' % (options.single_operation.strip())
      err_str += 'for the --single_operation (-o) option. Exiting.' 
      logger.error(err_str); print(err_str)
      sys.exit(EXIT_GENERAL_ERROR)  
      
  ### report summary stats ###
  
  check_failures_per_node_as_sorted_strings = {}
  for node_name in list_of_node_names:
    sorted_string = ''
    if len(check_failures_per_node[node_name]) == 0:
      sorted_string = 'All checks PASSED'
    else:
      sorted_check_failure_list = sorted(check_failures_per_node[node_name])
      for check_failure in sorted_check_failure_list:
        if sorted_string != '': sorted_string += ', '
        sorted_string += check_failure + ' check FAILED [%s]' % (severity_map[check_failure])
    check_failures_per_node_as_sorted_strings[node_name] = sorted_string
      
  check_failures_node_grouping = group_nodes_by_string(list_of_node_names, check_failures_per_node_as_sorted_strings)

  summary_string = 'Completed Execution on ' + str(count_of_nodes) + ' nodes: ' + ', '.join(list_of_node_names) + '\n'
  summary_string += 'Results: \n'
  for check_failures_sorted_string in sorted(check_failures_node_grouping, key=len):
    summary_string += '  ' + ', '.join(check_failures_node_grouping[check_failures_sorted_string])
    summary_string += ' - ' + check_failures_sorted_string + '\n'
  
  log_file_string = '\nAdditional details in log file: %s\n' % (os.path.abspath(options.log_file))
  
  logger.info('\n\n******* SUMMARY *******\n%s', summary_string)
  print '\n******* SUMMARY *******\n' + summary_string + log_file_string
  
  logger.info('Execution completed, exiting with status code %d', check_exit_code)

  sys.exit(check_exit_code)  

# Call the main() function to begin the program
if __name__ == '__main__':
  main(sys.argv[1:])
