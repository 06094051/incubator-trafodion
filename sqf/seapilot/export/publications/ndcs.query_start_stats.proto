import "common.info_header.proto";

package ndcs;

message query_start_stats
{
    required common.info_header header                      = 1;  // Common header for all Qpid messages
    optional string             session_id                  = 2;  // Unique session ID generated by the HPDCS server when the ODBC/JDBC connection was established. TIP: The session ID is fully contained within the query ID. To find all queries executed within a specific session, join the METRIC_SESSION_<n> view and the METRIC_QUERY_<n> view on the session ID.
    optional string             statement_id                = 3;  // Unique statement ID generated by the HPDCS server at the time the Prepare command was received.
    required string             query_id                    = 4;  // Unique identifier for the SQL statement, generated by the SQL compiler.
    optional string             statement_type              = 5;  // Type of SQL statement specified by the SQL compiler. The suffix _UNIQUE indicates that the statement operates on a single row. The suffix _NON_UNIQUE indicates that the statement could operate on multiple rows.
    optional string             client_id                   = 6;  // Name of the client workstation that initiated the query.
    optional string             user_name                   = 7;  // Name of the user connected to the instance.
    optional int64              user_id                     = 8;  // For future use.
    optional string             role_name                   = 9;  // Name of the role associated with the user who is connected to the instance.
    optional string             application_id              = 10; // Name of the client application that connects to the database and sends the query.
    optional string             node_name                   = 11; // For future use.
    optional string             cpu_pin                     = 12; // Process ID of the CPU of the HPDCS server that is handling the query and that reported the statistics.
    optional string             ds_name                     = 13; // Data-source name in the instance to which the client connected.
    optional string             service_name                = 14; // Name of the service registered with Workload Management Services (WMS).
    optional int64              time_ts_utc                 = 15; // Timestamp, in Coordinated Universal Time, indicating when query execution began (that is, when an execute statement is issued for the prepared query).
    required int64              time_ts_lct                 = 16; // Timestamp, in Local Civil Time, indicating when query execution began (that is, when an execute statement is issued for the prepared query). 
    optional int64		  entry_ts_utc		    = 17; // Timestamp, in Coordinated Universal Time, showing when this row was last updated.
    optional int64		  entry_ts_lct		    = 18; // Timestamp, in Local Civil Time, showing when this row was last updated. 
    optional int64              start_priority              = 19; // Starting priority of the Master Executor process for the query. NOTE: This field is for future use. Currently, the value is zero (0).
    optional int64              cmp_start_time_ts_utc       = 20; // Timestamp, in Coordinated Universal Time, indicating when query compilation began (that is, when a Prepare statement was issued for the query).
    optional int64              cmp_start_time_ts_lct       = 21; // Timestamp, in Local Civil Time, indicating when query compilation began (that is, when a Prepare statement was issued for the query).
    optional int64              cmp_end_time_ts_utc         = 22; // Timestamp, in Coordinated Universal Time, indicating when query compilation ended (that is, when the Prepare statement completed for this query).
    optional int64              cmp_end_time_ts_lct         = 23; // Timestamp, in Local Civil Time, indicating when query compilation ended (that is, when the Prepare statement completed for this query).
    optional int64              cmp_time                    = 24; // Calculated compile time in microseconds, computed as compilation end time minus compilation start time. This value is the amount of time needed to prepare the query and is obtained from the compiler.
    optional double             estimated_cost              = 25; // Estimated total cost (time in seconds) of the SQL operations for this query in the Master Executor. The estimate is determined when the query is prepared.
    optional double             estimated_cardinality       = 26; // Estimated number of rows that will be returned. The estimate is determined when the query is prepared.
    optional double             estimated_total_time        = 27; // Estimated time in seconds for the SQL operations for this query. This estimate includes estimates of I/O time, Message time, and Node time, and does not include Idle time. The estimate is determined when the query is prepared.
    optional double             estimated_io_time           = 28; // Estimate of the number of seconds of I/O time (seeks plus data transfer) to perform the I/O for this query. The estimate is determined when the query is prepared.
    optional double             estimated_msg_time          = 29; // Estimate of the number of seconds required for the messaging for this query, including local and remote messages, and the amount of data sent. The estimate is determined when the query is prepared.
    optional double             estimated_idle_time         = 30; // Estimate of the number of seconds to wait for an operation to complete, (for example, opening a table or starting a process). The estimate is determined when the query is prepared.
    optional double             estimated_cpu_time          = 31; // Estimate of the number of seconds of processor time it might take to execute instructions for this operator. The estimate is determined when the query is prepared.
    optional double             estimated_total_memory      = 32; // Estimate, in kilobytes, of the memory that the query plan will use. The value is computed based on operators that could potentially consume large amounts of memory: Hash Join, Hash Groupby, Sort, Merge Join, and Sequence.
    optional int64              estimated_resource_usage    = 33; // Estimate of the number of seconds of processor time that it might take to execute the query. The estimate is determined when the query is prepared. NOTE: This field is for future use. Currently, this value is zero (0).
    optional int64              cmp_affinity_num            = 34; // Affinity value used by the compiler to determine the CPU subset for placing ESPs for the query evenly across the available processors.
    optional int64              cmp_dop                     = 35; // Degree of parallelism used by the query, which is the number of ESP operators that are reused to parallelize a single fragment of the query plan. If different fragments in the same plan are parallelized to different extents, this counter reports the degree of parallelization of the fragment that is parallelized the most.
    optional int64              cmp_txn_needed              = 36; // Indicates whether the query is required to execute under a transaction. All SQL statements require a transaction except SELECT statements that use the READ UNCOMMITTED isolation level. Value is 1 (true) or 0 (false). 
    optional int64              cmp_mandate_x_prod          = 37; // Flags queries in which a join has been specified with no predicates. Joins with no predicates might result from predicate movement during optimization or simply because no predicate was specified for the join. Value is 1 (true) or 0 (false).
    optional int64              cmp_missing_stats           = 38; // Indicates whether single-column missing statistics warnings were raised during compilation (SQLCODE 6008 or 6011). Value is 1 (true) or 0 (false). Multi-column missing statistics warnings (SQLCODE 6007 or 6010) are not flagged in this field.
    optional int64              cmp_num_joins               = 39; // Number of joins in the query plan.
    optional int64              cmp_full_scan_table         = 40; // Indicates whether the query plan will perform a full scan on at least one table. Value is 1 (true) or 0 (false).
    optional int64              cmp_high_eid_max_buf_usage  = 41; // Indicates whether a high disk-processor buffer usage exists. Value is 1 (true) or 0 (false).
    optional double             cmp_rows_accessed_full_scan = 42; // Estimated number of rows accessed by a full scan of a table. Valid only if the query plan specifies "full scan on table." If the query plan contains more than one full scan operation, the largest number of rows accessed by all scans is reported here. Value is either the largest number of rows accessed, 0.0 when a full scan was performed on an empty table, or -1.0 when the query plan did not specify "full scan on table." 
    optional double             cmp_eid_rows_accessed       = 43; // Estimated number of rows to be accessed by all scan, insert, update, and delete operations in the query plan.
    optional double             cmp_eid_rows_used           = 44; // Estimated number of rows to be accessed by scan and insert operations in the query plan.
    optional int64              wms_start_time_ts_utc       = 45; // Timestamp, in Coordinated Universal Time, indicating when the query first entered Workload Management Services (WMS).
    optional int64              wms_start_time_ts_lct       = 46; // Timestamp, in Local Civil Time, indicating when the query first entered Workload Management Services (WMS).
    optional string             query_state                 = 47; // State of the query, which is one of these values: INIT, COMPLETED, REJECTED, or CANCELLED. For more information, see the SeaQuest Workload Management Services Guide.
    optional string             query_sub_state             = 48; // Substate of the query, which is dependent on the query state. For more information, see the SeaQuest Workload Management Services Guide.
    optional int64              wait_time                   = 49; // Amount of time, in seconds, the query waited in WMS for resources (such as memory or CPU time) to become available for the query to start executing (that is, the time from entry into the system to the time when the query actually starts to execute).
    optional int64              hold_time                   = 50; // Amount of time, in seconds, the query was in the holding state. A query in put in a holding state when: (1) a compilation rule in WMS evaluates to true, causing the query to be put on hold, or (2) a HOLD command puts the waiting query in a holding state. This field is updated before the query starts to execute.
    optional string             warn_level                  = 51; // Highest warning level triggered by the query as a result of a WMS rule evaluating to true. Possible levels include: LOW, MEDIUM, HIGH, or NONE.
    optional string             sql_text                    = 52; // The first 254 characters of query's SQL text. If the SQL text is longer than 254 characters, the SQLTEXT_OVERFLOW_INDICATOR field is set to 1 to indicate that only part of the SQL text fits in this field. TIP: To fetch the complete SQL text for the query, join the METRIC_QUERY_<n> view to the METRIC_QUERY_SQLTEXT_<n> view by using the EXEC_START_LCT_TS and QUERY_ID fields.
    optional int64              sql_text_overflow_indicator = 53; // Indicates the status of the SQL_TEXT field. A value of 0 indicates that the entire SQL text for the query is in the SQL_TEXT field. A value of 1 indicates that only a preview (the first 254 characters) of the SQL text is in the SQL_TEXT field.
    optional string             cmp_compiler_id             = 54; // For internal use.
    optional int64              cmp_cpu_path_length         = 55; // For internal use.
    optional int64              cmp_cpu_binder              = 56; // For internal use.
    optional int64              cmp_cpu_normalizer          = 57; // For internal use.
    optional int64              cmp_cpu_analyzer            = 58; // For internal use.
    optional int64              cmp_cpu_optimizer           = 59; // For internal use.
    optional int64              cmp_cpu_generator           = 60; // For internal use.
    optional int64              cmp_metadata_cache_hits     = 61; // For internal use.
    optional int64              cmp_metadata_cache_lookups  = 62; // For internal use.
    optional int64              cmp_query_cache_status      = 63; // For internal use.
    optional int64              cmp_histogram_cache_hits    = 64; // For internal use.
    optional int64              cmp_histogram_cache_lookups = 65; // For internal use.
    optional int64              cmp_stmt_heap_size          = 66; // For internal use.
    optional int64              cmp_context_heap_size       = 67; // For internal use.
    optional int64              cmp_optimization_tasks      = 68; // For internal use.
    optional int64              cmp_optimization_contexts   = 69; // For internal use.
    optional int32              cmp_is_recompile            = 70; // For internal use.
    optional string             aggregate_option            = 71; // Indicates whether this is an aggregated record. Value is Yes or No.
    optional string             connection_rule             = 72; // Displayed as <rule-name>:<expr-num>, where <rule-name> is the last connection rule evaluated for the query and <expr-num> is either the ordinal position of the rule expression that evaluated to true or ALL for all expressions evaluating to true.
    optional string             compilation_rule            = 73; // Displayed as <rule-name>:<expr-num>, where <rule-name> is the last compilation rule evaluated for the query and <expr-num> is either the ordinal position of the rule expression that evaluated to true or ALL for all expressions evaluating to true.
    optional string             execution_rule              = 74; // Displayed as <rule-name>:<expr-num>, where <rule-name> is the last execution rule evaluated for the query and <expr-num> is either the ordinal position of the rule expression that evaluated to true or ALL for all expressions evaluating to true.
    optional double             estimated_num_seq_ios       = 75; // For internal use.
    optional double             estimated_num_rand_ios      = 76; // For internal use.
    optional int64              cmp_number_of_bmos          = 77; // Number of Big Memory Operators (BMOs) in the query execution plan. The BMOs are hash join, hash groupby, sort, and merge join. When the quota or limit is reached on the BMOs' memory usage in an executor process, the memory overflow is written to a scratch file.
    optional string             cmp_overflow_mode           = 78; // Type of overflow mode that has been preconfigured for the system. The overflow mode represents the type of device to which the memory overflow is written. The overflow mode might be one of these values: (1) DISK for a hard disk drive or (2) SSD for a solid-state drive.
    optional int64              cmp_overflow_size           = 79; // Overflow size in kilobytes.
}
