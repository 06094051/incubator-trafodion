import "common.info_header.proto";

package ndcs;

message query_end_stats
{
    required common.info_header header                          = 1;  // Common header for all Qpid messages
    optional string             session_id                      = 2;  // Unique session ID generated by the HPDCS server when the ODBC/JDBC connection was established. TIP: The session ID is fully contained within the query ID. To find all queries executed within a specific session, join the METRIC_SESSION_<n> view and the METRIC_QUERY_<n> view on the session ID.
    optional string             statement_id                    = 3;  // Unique statement ID generated by the HPDCS server at the time the Prepare command was received.
    required string             query_id                        = 4;  // Unique identifier for the SQL statement, generated by the SQL compiler.
    optional string             parent_query_id                 = 5;  // Query ID for the immediate parent of the query. If the parent query ID is not present, the value returned is NONE. TIP: You can use the parent query ID to relate a child SQL statement to an immediate parent and then trace the relationship to find the original SQL statement.
    optional string             transaction_id                  = 6;  // Transaction identifier, in internal format, of the transaction involved in executing the query.
    optional string             statement_type                  = 7;  // Type of SQL statement specified by the SQL compiler. The suffix _UNIQUE indicates that the statement operates on a single row. The suffix _NON_UNIQUE indicates that the statement could operate on multiple rows.
    optional string             client_id                       = 8;  // Name of the client workstation that initiated the query.
    optional string             user_name                       = 9;  // Name of the user connected to the instance.
    optional int64              user_id                         = 10; // For future use.
    optional string             role_name                       = 11; // Name of the role associated with the user who is connected to the instance.
    optional string             application_id                  = 12; // Name of the client application that connects to the database and sends the query.
    optional string             node_name                       = 13; // For future use.
    optional string             cpu_pin	                        = 14; // Process ID of the CPU of the HPDCS server that is handling the query and that reported the statistics.
    optional string             ds_name                         = 15; // Data-source name in the instance to which the client connected.
    optional string             service_name                    = 16; // Name of the service registered with Workload Management Services (WMS).
    optional double             estimated_rows_accessed         = 17; // Estimated total number of rows accessed.
    optional double             estimated_rows_used             = 18; // Estimated total number of rows retrieved and/or actually used.
    optional int64              execute_start_time_ts_utc       = 19; // Timestamp, in Coordinated Universal Time, indicating when query execution began (that is, when an execute statement is issued for the prepared query).
    required int64              execute_start_time_ts_lct       = 20; // Timestamp, in Local Civil Time, indicating when query execution began (that is, when an execute statement is issued for the prepared query). If the query is controlled by Workload Management Services (WMS), this value reflects the time when the query is submitted to the WMS system. Depending on WMS rules and threshold settings, WMS might delay or cancel the actual launch (that is, execution) of the query. To calculate the actual execution launch time of the query, add the values of the SUBMIT_TS_LCT, WAIT_TIME, and HOLD_TIME columns. If the query is not under control of WMS, EXEC_START_LCT_TS represents the actual launch time.
    optional int64              execute_end_time_ts_utc         = 21; // Timestamp, in Coordinated Universal Time, indicating when query execution ended. TIP: You can use this value to monitor whether the query is still running.
    optional int64              execute_end_time_ts_lct         = 22; // Timestamp, in Local Civil Time, indicating when query execution ended.
    optional int64              time_ts_utc                     = 23; // Timestamp, in Coordinated Universal Time, indicating when query execution began (that is, when an execute statement is issued for the prepared query).
    optional int64              time_ts_lct                     = 24; // Timestamp, in Local Civil Time, indicating when query execution began (that is, when an execute statement is issued for the prepared query).
    optional int64              odbc_elapsed_time               = 25; // Elapsed clock time, in microseconds, from the time when the query started executing to the time when the results were returned.
    optional int64              odbc_execution_time             = 26; // CPU processing time, in microseconds, from the time when the query starts executing to the time when the results are returned. It does not include CPU time consumed by SQL executor child processes (ESPs) or disk processes for the query.
    optional int64              first_result_return_time_ts_utc = 27; // Timestamp, in Coordinated Universal Time, when SQL sends the first result row to the Master Executor process.
    optional int64              first_result_return_time_ts_lct = 28; // Timestamp, in Local Civil Time, when SQL sends the first result row to the Master Executor process.
    optional int64              rows_returned                   = 29; // Number of rows returned from the root operator to the Master Executor process and to the application in both the regular fetch and rowset fetch.
    optional int64              sql_process_busy_time           = 30; // An approximation, in microseconds, of the total node time spent in the Master Executor process and all ESPs involved in the query. This value is cumulative across all ESPs across all nodes.
    optional int64              num_sql_process                 = 31; // Number of SQL processes involved in the execution of the query.
    optional int64              number_of_rows                  = 32; // Number of rows actually inserted, updated, or deleted in the base tables by the query.
    optional int64              error_code                      = 33; // Query error code returned to the client. If the HPDCS process stops or fails, this field is set to 201. In this case, the last statistics available from WMS are retrievable from this Repository table or view.
    optional int64              sql_error_code                  = 34; // Top-level error code returned by the query, indicating whether the query completed successfully or with warnings or errors. A value of 100 indicates a completed SELECT, UPDATE, or DELETE statement with actual end statistics. Zero (0) indicates a completed INSERT statement or an incomplete query. Any other type of positive number indicates a warning. A negative number indicates an error. 
    optional int64              stats_error_code                = 35; // Internal error code, if any, returned by the runtime statistics (RMS) infrastructure while obtaining statistics for the query. This error code indicates whether the query completed successfully or with warnings or errors. The value is a positive number (warning), negative number (error), or 0 or 100 (success).
    optional int64              aqr_last_error                  = 36; // Last error code that triggered the query to be automatically retried.
    optional int64              aqr_num_retries                 = 37; // Total number of times that the query was retried.
    optional int64              aqr_delay_before_retry          = 38; // Delay time in seconds before the query was automatically retried.
    optional int64              wms_start_time_ts_utc           = 39; // Timestamp, in Coordinated Universal Time, indicating when the query first entered Workload Management Services (WMS).
    optional int64              wms_start_time_ts_lct           = 40; // Timestamp, in Local Civil Time, indicating when the query first entered Workload Management Services (WMS).
    optional string             query_state                     = 41; // State of the query, which is one of these values: INIT, COMPLETED, REJECTED, or CANCELLED. For more information, see the SeaQuest Workload Management Services Guide.
    optional string             query_sub_state                 = 42; // Substate of the query, which is dependent on the query state. For more information, see the SeaQuest Workload Management Services Guide.
    optional string             exec_state                      = 43; // Current operation of the executor on the query. Possible query states include: INITIAL, OPEN, EOF, CLOSE, DEALLOCATED, FETCH, CLOSE_TABLES, PROCESS_ENDED, UNKNOWN, or NULL.
    optional int64              exec_time                       = 44; // For future use.
    optional int64              wait_time                       = 45; // Amount of time, in seconds, the query waited in WMS for resources (such as memory or CPU time) to become available for the query to start executing (that is, the time from entry into the system to the time when the query actually starts to execute).
    optional int64              hold_time                       = 46; // Amount of time, in seconds, the query was in the holding state. A query in put in a holding state when: (1) a compilation rule in WMS evaluates to true, causing the query to be put on hold, or (2) a HOLD command puts the waiting query in a holding state. This field is updated before the query starts to execute.
    optional int64              suspend_time                    = 47; // Amount of time, in seconds, the query was in the suspended state. An executing query is put in a suspended state by the HOLD command.
    optional int64              open_busy_time                  = 48; // Time in microseconds the process spent doing file opens.
    optional int64              num_opens                       = 49; // Number of OPEN partition calls performed by the SQL executor on behalf of the query.
    optional int64              processes_created               = 50; // Number of new processes created by the executor on behalf of this process.
    optional int64              process_create_busy_time        = 51; // Time in microseconds the executor spent creating new processes.
    optional string             warn_level                      = 52; // Highest warning level triggered by the query as a result of a WMS rule evaluating to true. Possible levels include: LOW, MEDIUM, HIGH, or NONE.
    optional int64              rows_accessed                   = 53; // Total number of rows accessed in each table by all the scan, insert, update, and delete operators in the query plan.
    optional int64              rows_retrieved                  = 54; // Total number of rows retrieved and/or actually used by the statement. This value is the number of rows that were returned by the Executor in Disk (EID) process after evaluating non-key predicates.
    optional int64              disc_process_busy_time          = 55; // CPU time, in microseconds, for all disk processes involved in executing the query.
    optional int64              disc_reads                      = 56; // Number of physical disk I/O operations (reads or writes) caused by accessing the table.
    optional int64              space_total                     = 57; // Amount of static memory, in kilobytes, allocated (reserved) for query processes (master executor and ESPs) at the beginning of query execution. This value remains constant for the duration of query execution.
    optional int64              space_used                      = 58; // Amount of static memory, in kilobytes, used by query processes (master executor and ESPs) at the end of query execution. This value should be less than or equal to the SQL_SPACE_ALLOCATED value.
    optional int64              heap_total                      = 59; // Amount of dynamic memory, in kilobytes, allocated (reserved) for query processes (master executor and ESPs) at the beginning of query execution. The processes that execute the query request this memory during execution, thus the amount can change as the query runs.
    optional int64              heap_used                       = 60; // Amount of dynamic memory, in kilobytes, actually used for query processes (master executor and ESPs) during query execution. This is the value at the end of query execution.
    optional int64              total_memory                    = 61; // Total memory allocated to the query. This is the sum of SQL_SPACE_USED and SQL_HEAP_USED.
    optional int64              max_memory_used                 = 62; // Maximum memory, in kilobytes, used during the lifetime of the query. 
    optional int64              eid_space_total                 = 63; // Amount of static memory, in kilobytes, allocated (reserved) for the Executor in Disk (EID) processes involved in query execution. This is the value at the beginning of query execution. The EID process is separate from master and ESPs, and all the EID memory values are in addition to the SQL memory values.
    optional int64              eid_space_used                  = 64; // Amount of static memory, in kilobytes, actually used by the Executor in Disk (EID) processes involved in query execution. This is the value at the end of query execution.
    optional int64              eid_heap_total                  = 65; // Amount of dynamic memory, in kilobytes, allocated for the Executor in Disk (EID) processes involved in query execution. This is the value at the beginning of query execution.
    optional int64              eid_heap_used                   = 66; // Amount of dynamic memory, in kilobytes, actually used for the Executor in Disk (EID) processes involved in query execution. This is the value at the end of query execution.
    optional int64              msgs_to_disc                    = 67; // Number of messages sent to the disk process (that is, the number of messages exchanged between the file system and the disk process).
    optional int64              msgs_bytes_to_disc              = 68; // Size, in bytes, of the total amount of message data sent to the disk process.
    optional int64              num_rqst_msgs                   = 69; // Number of messages that are initiated from the Master Executor process to ESPs or from ESP to ESP. This count includes both control and data messages.
    optional int64              num_rqst_msg_bytes              = 70; // Number of message bytes sent as part of NUM_REQUEST_MSGS.
    optional int64              num_rply_msgs                   = 71; // Number of reply messages from ESPs.
    optional int64              num_rply_msg_bytes              = 72; // Number of bytes sent as part of the replies from ESPs.
    optional int64              lock_waits                      = 73; // Number of times the statement waited for a lock request (concurrency cost). Access to the table is delayed because of conflicting locks. Ideally, this number is zero or very small.
    optional int64              lock_escalation                 = 74; // Cumulative number of times record (row) locks were escalated to file (table) locks during query execution.
    optional int64              total_executes                  = 75; // Total number of SQLExecute calls.
    optional string             error_text                      = 76; // Message text of the error returned by SQL. See the SQL_ERROR_CODE field.
    optional int64              aggregate_total                 = 77; // Total number of queries aggregated.
    optional string             execution_rule                  = 78; // Displayed as <rule-name>:<expr-num>, where <rule-name> is the last execution rule evaluated for the query and <expr-num> is either the ordinal position of the rule expression that evaluated to true or ALL for all expressions evaluating to true.
    optional int64              ovf_file_count		        = 79; // Number of scratch files that are created to execute the query. The default size of a scratch file is two gigabytes.
    optional int64              ovf_space_allocated             = 80; // Space allocated for memory overflow, in kilobytes, which is the number of scratch files that are used multiplied by two gigabytes, which is the maximum size of a scratch file.
    optional int64              ovf_space_used                  = 81; // Space used for memory overflow, in kilobytes, which is the same as OVF_BUFFER_BYTES_WRITTEN.
    optional int64              ovf_block_size                  = 82; // Size, in kilobytes, of the buffer block that is used to read from or write to a scratch file.
    optional int64              ovf_ios                         = 83; // Number of file-system calls involved in writing and reading buffer blocks to and from scratch files, which is the sum of OVF_WRITE_COUNT and OVF_READ_COUNT. 
    optional int64              ovf_message_buffers_to          = 84; // Number of buffer blocks written to scratch files.       
    optional int64              ovf_message_to                  = 85; // Number of file-system calls involved in writing buffer blocks to scratch files. One call writes multiple buffer blocks at once.       
    optional int64              ovf_message_bytes_to            = 86; // Total size of the buffer blocks written to scratch files, in kilobytes, which is OVF_BUFFER_BLOCKS_WRITTEN multiplied by OVF_BLOCK_SIZE.
    optional int64              ovf_message_buffers_out         = 87; // Number of buffer blocks read from scratch files. 
    optional int64              ovf_message_out                 = 88; // Number of file-system calls involved in reading buffer blocks from scratch files. One call reads multiple buffer blocks at once. 
    optional int64              ovf_message_bytes_out           = 89; // Total size of the buffer blocks read from scratch files, in kilobytes, which is OVF_BUFFER_BLOCKS_READ multiplied by OVF_BLOCK_SIZE.
    optional int64              suspended_ts_utc                = 90; // Timestamp, in Coordinated Universal Time, indicating when the query was suspended.
    optional int64              suspended_ts_lct                = 91; // Timestamp, in Local Civil Time, indicating when the query was suspended.
    optional int64              released_ts_utc		        = 92; // Timestamp, in Coordinated Universal Time, indicating when the query was released from the suspended state.
    optional int64              released_ts_lct		        = 93; // Timestamp, in Local Civil Time, indicating when the query was released from the suspended state.
    optional int64              cancelled_ts_utc		= 94; // Timestamp, in Coordinated Universal Time, indicating when the query was canceled.
    optional int64              cancelled_ts_lct		= 95; // Timestamp, in Local Civil Time, indicating when the query was canceled.
    optional int64              num_cpus		        = 96; // Total number of cpus.
    optional int64              udr_process_busy_time		= 97; // UDR process busy time.
    optional string             query_subtype		        = 98; // The subtype of query.
    optional string             parent_system_name		= 99; // The name of parent system.
    optional int32              pertable_stats                  = 100; // pertable statistics.
    optional int64	  	entry_ts_utc			= 101; // Timestamp, in Coordinated Universal Time, showing when this row was last updated.
    optional int64	  	entry_ts_lct			= 102; // Timestamp, in Local Civil Time, showing when this row was last updated.
    optional int64              start_priority              	= 103; // Starting priority of the Master Executor process for the query. NOTE: This field is for future use. Currently, the value is zero (0).
    optional int64              cmp_start_time_ts_utc       	= 104; // Timestamp, in Coordinated Universal Time, indicating when query compilation began (that is, when a Prepare statement was issued for the query).
    optional int64              cmp_start_time_ts_lct       	= 105; // Timestamp, in Local Civil Time, indicating when query compilation began (that is, when a Prepare statement was issued for the query).
    optional int64              cmp_end_time_ts_utc         	= 106; // Timestamp, in Coordinated Universal Time, indicating when query compilation ended (that is, when the Prepare statement completed for this query).
    optional int64              cmp_end_time_ts_lct         	= 107; // Timestamp, in Local Civil Time, indicating when query compilation ended (that is, when the Prepare statement completed for this query).
    optional int64              cmp_time                    	= 108; // Calculated compile time in microseconds, computed as compilation end time minus compilation start time. This value is the amount of time needed to prepare the query and is obtained from the compiler.
    optional double             estimated_cost              	= 109; // Estimated total cost (time in seconds) of the SQL operations for this query in the Master Executor. The estimate is determined when the query is prepared.
    optional double             estimated_cardinality       	= 110; // Estimated number of rows that will be returned. The estimate is determined when the query is prepared.
    optional double             estimated_total_time        	= 111; // Estimated time in seconds for the SQL operations for this query. This estimate includes estimates of I/O time, Message time, and Node time, and does not include Idle time. The estimate is determined when the query is prepared.
    optional double             estimated_io_time           	= 112; // Estimate of the number of seconds of I/O time (seeks plus data transfer) to perform the I/O for this query. The estimate is determined when the query is prepared.
    optional double             estimated_msg_time          	= 113; // Estimate of the number of seconds required for the messaging for this query, including local and remote messages, and the amount of data sent. The estimate is determined when the query is prepared.
    optional double             estimated_idle_time         	= 114; // Estimate of the number of seconds to wait for an operation to complete, (for example, opening a table or starting a process). The estimate is determined when the query is prepared.
    optional double             estimated_cpu_time          	= 115; // Estimate of the number of seconds of processor time it might take to execute instructions for this operator. The estimate is determined when the query is prepared.
    optional double             estimated_total_memory      	= 116; // Estimate, in kilobytes, of the memory that the query plan will use. The value is computed based on operators that could potentially consume large amounts of memory: Hash Join, Hash Groupby, Sort, Merge Join, and Sequence.
    optional int64              estimated_resource_usage    	= 117; // Estimate of the number of seconds of processor time that it might take to execute the query. The estimate is determined when the query is prepared. NOTE: This field is for future use. Currently, this value is zero (0).
    optional int64              cmp_affinity_num            	= 118; // Affinity value used by the compiler to determine the CPU subset for placing ESPs for the query evenly across the available processors.
    optional int64              cmp_dop                     	= 119; // Degree of parallelism used by the query, which is the number of ESP operators that are reused to parallelize a single fragment of the query plan. If different fragments in the same plan are parallelized to different extents, this counter reports the degree of parallelization of the fragment that is parallelized the most.
    optional int64              cmp_txn_needed              	= 120; // Indicates whether the query is required to execute under a transaction. All SQL statements require a transaction except SELECT statements that use the READ UNCOMMITTED isolation level. Value is 1 (true) or 0 (false). 
    optional int64              cmp_mandate_x_prod          	= 121; // Flags queries in which a join has been specified with no predicates. Joins with no predicates might result from predicate movement during optimization or simply because no predicate was specified for the join. Value is 1 (true) or 0 (false).
    optional int64              cmp_missing_stats           	= 122; // Indicates whether single-column missing statistics warnings were raised during compilation (SQLCODE 6008 or 6011). Value is 1 (true) or 0 (false). Multi-column missing statistics warnings (SQLCODE 6007 or 6010) are not flagged in this field.
    optional int64              cmp_num_joins               	= 123; // Number of joins in the query plan.
    optional int64              cmp_full_scan_table         	= 124; // Indicates whether the query plan will perform a full scan on at least one table. Value is 1 (true) or 0 (false).
    optional int64              cmp_high_eid_max_buf_usage  	= 125; // Indicates whether a high disk-processor buffer usage exists. Value is 1 (true) or 0 (false).
    optional double             cmp_rows_accessed_full_scan 	= 126; // Estimated number of rows accessed by a full scan of a table. Valid only if the query plan specifies "full scan on table." If the query plan contains more than one full scan operation, the largest number of rows accessed by all scans is reported here. Value is either the largest number of rows accessed, 0.0 when a full scan was performed on an empty table, or -1.0 when the query plan did not specify "full scan on table." 
    optional double             cmp_eid_rows_accessed       	= 127; // Estimated number of rows to be accessed by all scan, insert, update, and delete operations in the query plan.
    optional double             cmp_eid_rows_used		= 128; // Estimated number of rows to be accessed by scan and insert operations in the query plan.
    optional string             sql_text                    	= 129; // The first 254 characters of query's SQL text. If the SQL text is longer than 254 characters, the SQLTEXT_OVERFLOW_INDICATOR field is set to 1 to indicate that only part of the SQL text fits in this field. TIP: To fetch the complete SQL text for the query, join the METRIC_QUERY_<n> view to the METRIC_QUERY_SQLTEXT_<n> view by using the EXEC_START_LCT_TS and QUERY_ID fields.
    optional int64              sql_text_overflow_indicator 	= 130; // Indicates the status of the SQL_TEXT field. A value of 0 indicates that the entire SQL text for the query is in the SQL_TEXT field. A value of 1 indicates that only a preview (the first 254 characters) of the SQL text is in the SQL_TEXT field.
    optional string             cmp_compiler_id             	= 131; // For internal use.
    optional int64              cmp_cpu_path_length         	= 132; // For internal use.
    optional int64              cmp_cpu_binder              	= 133; // For internal use.
    optional int64              cmp_cpu_normalizer          	= 134; // For internal use.
    optional int64              cmp_cpu_analyzer            	= 135; // For internal use.
    optional int64              cmp_cpu_optimizer           	= 136; // For internal use.
    optional int64              cmp_cpu_generator           	= 137; // For internal use.
    optional int64              cmp_metadata_cache_hits     	= 138; // For internal use.
    optional int64              cmp_metadata_cache_lookups  	= 139; // For internal use.
    optional int64              cmp_query_cache_status      	= 140; // For internal use.
    optional int64              cmp_histogram_cache_hits    	= 141; // For internal use.
    optional int64              cmp_histogram_cache_lookups 	= 142; // For internal use.
    optional int64              cmp_stmt_heap_size          	= 143; // For internal use.
    optional int64              cmp_context_heap_size       	= 144; // For internal use.
    optional int64              cmp_optimization_tasks      	= 145; // For internal use.
    optional int64              cmp_optimization_contexts   	= 146; // For internal use.
    optional int32              cmp_is_recompile            	= 147; // For internal use.
    optional string             aggregate_option            	= 148; // Indicates whether this is an aggregated record. Value is Yes or No.
    optional string             connection_rule             	= 149; // Displayed as <rule-name>:<expr-num>, where <rule-name> is the last connection rule evaluated for the query and <expr-num> is either the ordinal position of the rule expression that evaluated to true or ALL for all expressions evaluating to true.
    optional string             compilation_rule            	= 150; // Displayed as <rule-name>:<expr-num>, where <rule-name> is the last compilation rule evaluated for the query and <expr-num> is either the ordinal position of the rule expression that evaluated to true or ALL for all expressions evaluating to true.
    optional double             estimated_num_seq_ios       	= 151; // For internal use.
    optional double             estimated_num_rand_ios      	= 152; // For internal use.
    optional int64              cmp_number_of_bmos          	= 153; // Number of Big Memory Operators (BMOs) in the query execution plan. The BMOs are hash join, hash groupby, sort, and merge join. When the quota or limit is reached on the BMOs' memory usage in an executor process, the memory overflow is written to a scratch file.
    optional string             cmp_overflow_mode           	= 154; // Type of overflow mode that has been preconfigured for the system. The overflow mode represents the type of device to which the memory overflow is written. The overflow mode might be one of these values: (1) DISK for a hard disk drive or (2) SSD for a solid-state drive.
    optional int64              cmp_overflow_size           	= 155; // Overflow size in kilobytes.
}
